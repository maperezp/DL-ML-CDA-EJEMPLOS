


# 2) Mezcla de confianza asumida vía distribución Laplace calibrada con el MAE
median_price = price_summary.loc['mediana', 'COP']
thresholds_pct = np.array([0.15, 0.30])
thresholds_abs = thresholds_pct * median_price
scale = float(rf_test_metrics['MAE'].replace(',', ''))


prob_high = 1 - np.exp(-thresholds_abs[0] / scale)
prob_mid = (1 - np.exp(-thresholds_abs[1] / scale)) - prob_high
prob_low = max(0.0, 1 - (prob_high + prob_mid))
prob_segments = np.array([prob_high, prob_mid, prob_low])
prob_segments = prob_segments / prob_segments.sum()

error_pct_midpoints = np.array([0.10, 0.225, 0.45])
review_hours = np.array([2, 4, 8])
external_fee_factor = np.array([0.0, 0.5, 1.0])
penalty_share = np.array([0.05, 0.15, 0.30])

print("\n--- Matriz de escenarios por banda de error ---")
columns = ['Segmento', 'Probabilidad', 'Horas_revision', 'Costo_modelo', 'Costo_error', 'Ganancia_neta', 'Contribucion_esperada']
display(segments[columns].round(2))

# 3) Costos base
perito_salary = 4_600_000
benefits_multiplier = 1.35
hours_per_month = 220
perito_hour_cost = perito_salary * benefits_multiplier / hours_per_month

manual_hours = 8
manual_fee = max(median_price * 0.003, 600_000)
manual_internal = perito_hour_cost * manual_hours
manual_total = manual_fee + manual_internal

inference_cost = 10_000
commission_rate = 0.03

segments = pd.DataFrame({
    'Segmento': ['Alta (<15% error)', 'Media (15%-30%)', 'Baja (>30%)'],
    'Probabilidad': prob_segments,
    'Horas_revision': review_hours,
    'Factor_perito_externo': external_fee_factor,
    'Error_pct_ref': error_pct_midpoints,
    'Penalizacion_ingreso': penalty_share
})

segments['Costo_modelo'] = (
    segments['Horas_revision'] * perito_hour_cost
    + segments['Factor_perito_externo'] * manual_fee
    + inference_cost
)
segments['Ahorro_laboral'] = manual_total - segments['Costo_modelo']
segments['Costo_error'] = (
    segments['Error_pct_ref']
    * median_price
    * commission_rate
    * segments['Penalizacion_ingreso']
)
segments['Ganancia_neta'] = segments['Ahorro_laboral'] - segments['Costo_error']
segments['Contribucion_esperada'] = segments['Ganancia_neta'] * segments['Probabilidad']

expected_gain = segments['Contribucion_esperada'].sum()
expected_hours = (segments['Horas_revision'] * segments['Probabilidad']).sum()
time_saving_hours = manual_hours - expected_hours

# 4) Inversión del proyecto y escenarios de break-even
investment_breakdown = pd.DataFrame([
    {'Concepto': 'Científico/a de datos senior', 'Horas': 160, 'Tarifa_hora': 120_000, 'Subtotal': np.nan},
    {'Concepto': 'ML Engineer / MLOps', 'Horas': 120, 'Tarifa_hora': 90_000, 'Subtotal': np.nan},
    {'Concepto': 'Product Owner / experto negocio', 'Horas': 60, 'Tarifa_hora': 70_000, 'Subtotal': np.nan},
    {'Concepto': 'Infraestructura + licencias (12 semanas)', 'Horas': 0, 'Tarifa_hora': 0, 'Subtotal': 5_000_000}
])
investment_breakdown['Subtotal'] = investment_breakdown['Subtotal'].fillna(0)
investment_breakdown['Subtotal'] += investment_breakdown['Horas'] * investment_breakdown['Tarifa_hora']
total_investment = investment_breakdown['Subtotal'].sum()

break_even_estimations = np.ceil(total_investment / expected_gain)

volume_table = pd.DataFrame({
    'Estimaciones_mes': [100, 300, 600]
})
volume_table['Ahorro_estimado'] = volume_table['Estimaciones_mes'] * expected_gain
volume_table['Meses_a_break_even'] = total_investment / volume_table['Ahorro_estimado']

summary_headline = pd.Series({
    'Costo_manual_total': manual_total,
    'Costo_modelo_promedio': manual_total - expected_gain,
    'Ganancia_esperada_por_estimacion': expected_gain,
    'Horas_ahorradas_promedio': time_saving_hours,
    'Break_even_estimaciones': break_even_estimations,
}, name='Resumen')



print("\n--- Inversión estimada ---")
display(investment_breakdown[['Concepto', 'Horas', 'Tarifa_hora', 'Subtotal']])
print("\n--- Escenarios mensuales ---")
display(volume_table.round(2))
print("\n--- Resumen ---")
display(summary_headline.to_frame())